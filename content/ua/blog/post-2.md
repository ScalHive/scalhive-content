---
title: "Розробка на основі стовбуру (Trunk): Гілка для релізу"
date: 2024-01-29T21:30:00+02:00
type: article
featured_image: '/static-blog-images/post-2/banner.png'
keywords: ['trunk', 'розробка', 'VCS', 'робота']
---
        Відгалуження: лише за необхідності, за несумісною політикою, із запізненням і замість заморожування
###### Лаура Вінгерд і Крістофер Сейвальд (технічний документ високого рівня 'SCM Best Practices' 1998 року від 'Perforce')

Якщо команда випускає робочі релізи щомісяця, то їм також доведеться випускати релізи з виправленням помилок між 
запланованими релізами.  Для цього команди, що використовують Trunk-Based Development, часто створюють релізну гілку завчасно, наприклад, за кілька днів до релізу. Це стає стабільним місцем, оскільки розробники продовжують активно 
комітити зміни в основну гілку. Несумісна політика (див. Wingerd & Seiwald вище) стверджує, що релізна гілка
«не повинна отримувати продовження розробки».

{{< img src="/blog-images/post-2/figure-1.png" alt="Trunk, дві з половиною релізні гілки, п'ять релізів (два заплановані, три незаплановані), та два Черрі-пік виправлення помилок" css_class="img-scale-down"css_class="img-scale-down">}}

## {{< color-text text="Хто тут комітить?" >}}
Розробники комітять (зелені крапки) при найвищій пропускній здатності до стовбура, і не сповільнюються та не зависають 
навколо зрізу гілки чи наближення до релізу. Розробники як група **не** комітять в гілку релізу (див. нижче).

{{< img src="/blog-images/post-2/figure-2.png" css_class="img-scale-down"css_class="img-scale-down">}}

Сам зріз гілки є комітом. Subversion і Perforce технічно мали б тут більший коміт, але всі системи VCS, які 
використовуються сьогодні, вважали б коміт «легким» з точки зору його впливу на історію/сховище та часу, витраченого на 
створення. Ця червона крапка є випадковим зривом збірки, який було виправлено (якимось чином) незабаром після цього.

## {{< color-text text="Пізнє створення гілок релізу" >}}
Деякі команди звільняються від мітки на стовбурі та не створюють гілки в той час. Це саме по собі є альтернативною 
практикою до цієї, **«гілки для релізу»**. Ці команди чекають помилки, яку потрібно виправити для релізу, перш ніж 
створювати гілку з тегу релізу (якщо вони не збираються просто випускати інший реліз із стовбура). Бред Епплтон 
зазначає, що багато хто не усвідомлює, що гілки можуть бути створені заднім числом. Це використовується тут у випадку 
помилок після «релізу від тегу» або навіть змін для точкових релізів.

## {{< color-text text="Виправлення виробничих помилок на гілці Trunk" >}}
Найкраща практика для команд, що використовують Trunk-Based Development, полягає в тому, щоб відтворити помилку на основній гілці, виправити її там разом з тестом, переконатися, що вона пройшла перевірку CI-сервером, а потім вибрати цю зміну (cherry-pick) в гілку релізу та зачекати, поки її також перевірить CI-сервер, орієнтований на гілку релізу. Так, CI-пайплайн, який захищає основну гілку, буде дублюватися для захисту активних релізних гілок також.

**Черрі-пік не є звичайним злиттям**

`Черрі-пік злиття бере певний комміт (або коміти) і об’єднує його з гілкою призначення. Він пропускає один або кілька 
комітів, які відбулися до нього, але після того, як гілку було вирізано. Усі інструменти VCS відстежують, які коміти 
було об’єднано, а які ні, тож пізніше ви можете зробити більше вибору.`

**Черрі-піки ТІЛЬКИ із Trunk до гілки**
Ви не повинні виправляти помилки на гілці релізу, очікуючи, що черрі-піки збиратимуть їх назад в Trunk.
**Чому?**
Ну на випадок, якщо ви у поспіху забудете це зробити. Забуття означає регрес у виробництві через кілька тижнів (і когось
звільнять). Це може статися, якщо втомлений розробник, який хоче повернутися спати, лагодить речі вночі.

{{< img src="/blog-images/post-2/figure-3.png" css_class="img-scale-down"css_class="img-scale-down">}}

Це правило для розробки на основі стовбуру залишається важко прийнятним навіть у командах, які практикують лише розробку на
основі магістралі. Однак потрібна лише одна регресія, щоб змінити політику для команди. Звичайно, іноді ви **абсолютно 
не можете** відтворити помилку на гілці Trunk. У цьому випадку ви повинні зробити це навпаки, незважаючи на все вищезгадане,
але розумійте, що ви ввели ризик регресу.

## {{< color-text text="Патч релізів" >}}
Можливо, ваша команда виштовхнула випуск із гілки релізу, і тепер має помилку, яку потрібно виправити у виробництві.
Якщо каденцію релізу це влаштовує, черрі-пік виправлення помилок із Trunk до гілки релізу та точковий випуск з тієї ж
гілки підійде.

## {{< color-text text="Тег замість гілки" >}}
Реліз від тегу на Trunk є гідною оптимізацією для багатьох команд, якщо це можливо. Тег можна пронумерувати для релізу 
(скажімо, v1.1.1), і гілки можна повністю уникнути. Можливо, якщо є помилка у виробництві та заднім числом створено 
гілку з цього тегу, і звідти може відбутися патч релізу (див. вище).

## {{< color-text text="Видалення гілки релізу" >}}
Гілки релізу видаляються через деякий час після припинення діяльності з релізу. Не відразу, але коли буде зрозуміло, що 
реліз більше не у виробництві. Гілки випуску НЕ об’єднуються назад у Trunk. Зазвичай це відбувається тоді, коли релізи з
наступних гілок релізів починають працювати. Це нешкідлива операція з очищення — гілки можна знову досить легко 
відновити в усіх варіантах VCS. У git потрібно створити тег із випущеного коміту перед видаленням гілки релізу, оскільки
вивішені коміти збиратимуть сміття.

### {{< color-text text="Посилання на першоджерело:" >}}
* https://trunkbaseddevelopment.com/branch-for-release/
