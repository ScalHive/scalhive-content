---
title: "Розробка на основі стовбуру (Trunk): Гілка для релізу"
date: 2024-01-29T21:30:00+02:00
type: article
featured_image: '/static-blog-images/post-2/banner.png'
keywords: ['trunk', 'розробка', 'VCS', 'робота']
---
        Відгалуження: лише за необхідності, за несумісною політикою, із запізненням і замість заморожування
###### Лаура Вінгерд і Крістофер Сейвальд (технічний документ високого рівня 'SCM Best Practices' 1998 року від 'Perforce')

Якщо команда випускає робочі релізи щомісяця, то їм також доведеться випускати релізи з виправленням помилок між 
запланованими релізами. Щоб полегшити це, команди магістральних розробників зазвичай створюють гілку випуску точно 
вчасно – скажімо, за кілька днів до випуску. Це стає стабільним місцем, враховуючи, що розробники все ще передають свої 
коміти в Trunk на повній швидкості. Несумісна політика (посилання на Wingerd & Seiwald вище), згідно з якою гілка релізу
«не повинна отримувати продовження розробки».

{{< img src="/blog-images/post-2/figure-1.png" alt="Trunk, two and a half release branches, five releases (two planned, three unplanned), and two cherry-pick bug fixes" css_class="img-scale-down"css_class="img-scale-down">}}

## {{< color-text text="Хто тут комітить?" >}}
Розробники комітять (зелені крапки) при найвищій пропускній здатності до стовбура, і не сповільнюються та не зависають 
навколо зрізу гілки чи наближення до релізу. Розробники як група **не** комітять в гілку релізу (див. нижче).

{{< img src="/blog-images/post-2/figure-2.png" css_class="img-scale-down"css_class="img-scale-down">}}

Сам зріз гілки є комітом. Subversion і Perforce технічно мали б тут більший коміт, але всі системи VCS, які 
використовуються сьогодні, вважали б коміт «легким» з точки зору його впливу на історію/сховище та часу, витраченого на 
створення. Ця червона крапка є випадковим зривом збірки, який було виправлено (якимось чином) незабаром після цього.

## {{< color-text text="Пізнє створення гілок релізу" >}}
Деякі команди звільняються від мітки на стовбурі та не створюють гілки в той час. Це саме по собі є альтернативною 
практикою до цієї, **«гілки для випуску»**. Ці команди чекають помилки, яку потрібно виправити для релізу, перш ніж 
створювати гілку з тегу релізу (якщо вони не збираються просто випускати інший реліз із стовбура). Бред Епплтон 
зазначає, що багато хто не усвідомлює, що гілки можуть бути створені заднім числом. Це використовується тут у випадку 
помилок після «релізу від тегу» або навіть змін для точкових релізів.

## {{< color-text text="Виправлення production багів на Trunk" >}}
Найкраща практика для команд розробників на основі Trunk — відтворити помилку на Trunk, виправити її там за допомогою 
тесту, спостерігати за тим, щоб перевірити сервер CI, а потім вибрати це для гілки релізу та дочекатися фокусування 
сервера CI на гілці релізу, щоб перевірити це також. Так, конвеєр CI, який охороняє Trunk, буде продубльований, щоб 
також охороняти активні гілки релізу.

**Черрі-пік не є звичайним злиттям**

`Черрі-пік злиття бере певний комміт (або коміти) і об’єднує його з гілкою призначення. Він пропускає один або кілька 
комітів, які відбулися до нього, але після того, як гілку було вирізано. Усі інструменти VCS відстежують, які коміти 
було об’єднано, а які ні, тож пізніше ви можете зробити більше вибору.`

**Черрі-піки ТІЛЬКИ із Trunk до гілки**
Ви не повинні виправляти помилки на гілці релізу, очікуючи, що черрі-піки збиратимуть їх назад в Trunk.
**Чому?**
Ну на випадок, якщо ви у поспіху забудете це зробити. Забуття означає регрес у виробництві через кілька тижнів (і когось
звільнять). Це може статися, якщо втомлений розробник, який хоче повернутися спати, лагодить речі вночі.

{{< img src="/blog-images/post-2/figure-3.png" css_class="img-scale-down"css_class="img-scale-down">}}

Це правило для розробки на основі Trunk залишається важко прийнятним навіть у командах, які практикують лише розробку на
основі магістралі. Однак потрібна лише одна регресія, щоб змінити політику для команди. Звичайно, іноді ви **абсолютно 
не можете** відтворити помилку на Trunk. У цьому випадку ви повинні зробити це навпаки, незважаючи на все вищезгадане,
але розумійте, що ви ввели ризик регресу.

## {{< color-text text="Патч релізів" >}}
Можливо, ваша команда виштовхнула випуск із гілки релізу, і тепер має помилку, яку потрібно виправити у виробництві.
Якщо каденцію релізу це влаштовує, черрі-пік виправлення помилок із Trunk до гілки релізу та точковий випуск з тієї ж
гілки підійде.

## {{< color-text text="Тег замість гілки" >}}
Реліз від тегу на Trunk є гідною оптимізацією для багатьох команд, якщо це можливо. Тег можна пронумерувати для релізу 
(скажімо, v1.1.1), і гілки можна повністю уникнути. Можливо, якщо є помилка у виробництві та заднім числом створено 
гілку з цього тегу, і звідти може відбутися патч релізу (див. вище).

## {{< color-text text="Видалення гілки релізу" >}}
Гілки релізу видаляються через деякий час після припинення діяльності з релізу. Не відразу, але коли буде зрозуміло, що 
реліз більше не у виробництві. Гілки випуску НЕ об’єднуються назад у Trunk. Зазвичай це відбувається тоді, коли релізи з
наступних гілок релізів починають працювати. Це нешкідлива операція з очищення — гілки можна знову досить легко 
відновити в усіх варіантах VCS. У git потрібно створити тег із випущеного коміту перед видаленням гілки релізу, оскільки
вивішені коміти збиратимуть сміття.

### {{< color-text text="Посилання на першоджерело:" >}}
* https://trunkbaseddevelopment.com/branch-for-release/
